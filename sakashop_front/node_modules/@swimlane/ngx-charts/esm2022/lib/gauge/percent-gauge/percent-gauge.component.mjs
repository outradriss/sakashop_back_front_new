import { Component, Input, ViewEncapsulation, ChangeDetectionStrategy } from '@angular/core';
import { BaseChartComponent } from '../../common/base-chart.component';
import { calculateViewDimensions } from '../../common/view-dimensions.helper';
import { ColorHelper } from '../../common/color.helper';
import { ScaleType } from '../../common/types/scale-type.enum';
import { id } from '../../utils/id';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "../../common/charts/chart.component";
export class PercentGaugeComponent extends BaseChartComponent {
    constructor() {
        super(...arguments);
        this.max = 100;
        this.value = 0;
        this.target = 75;
        this.targetLabel = 'Target';
        this.showLabel = true;
        this.defaultMargin = [20, 40, 20, 40];
        this.margin = [20, 40, 20, 40];
        this.ticks = [];
    }
    update() {
        super.update();
        this.circleMaskId = `circleMask${id()}`;
        this.margin = [...this.defaultMargin];
        if (this.showLabel) {
            this.margin[2] = 50;
        }
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin
        });
        this.percent = this.getPercentage();
        this.ticHeight = Math.min(this.dims.width, this.dims.height) / 10;
        this.radius = Math.min(this.dims.width, this.dims.height) / 2 - this.ticHeight / 2;
        this.circumference = 2 * Math.PI * this.radius;
        this.dashes = `${this.radius / 60} ${this.circumference / 60 - this.radius / 60}`;
        this.valueFontSize = Math.floor(this.radius / 3);
        this.targetRadius = this.radius / 4;
        this.targetTextTransform = `translate(${-this.targetRadius / 2}, ${-this.targetRadius / 2}), scale(${this.targetRadius / 28})`;
        this.valueDomain = this.getValueDomain();
        this.displayValue = this.getDisplayValue();
        this.setColors();
        this.targetColor = this.colors.getColor((this.target / 100) * this.max);
        const xOffset = this.margin[3] + this.dims.width / 2;
        const yOffset = this.margin[0] + this.dims.height / 2;
        this.transform = `translate(${xOffset}, ${yOffset})`;
        this.labelTransform = `translate(0, ${this.height / 2 + this.radius + this.margin[0] + this.ticHeight / 2 - 3})`;
        const angle = (this.target / 100) * Math.PI * 2 - Math.PI / 2;
        this.targetTransform = `translate(${this.radius * 0.97 * Math.cos(angle) + this.targetRadius / 2}, ${this.radius * 0.97 * Math.sin(angle) + this.targetRadius / 2})`;
        this.generateticks();
        this.cd.markForCheck();
    }
    generateCirclePoints(radius, numPoints) {
        const points = [];
        for (let i = 0; i < numPoints; i++) {
            const angle = (i / numPoints) * 2 * Math.PI;
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);
            points.push({ x, y });
        }
        return points;
    }
    generateticks() {
        const numPoints = 60;
        const points = this.generateCirclePoints(this.radius, numPoints);
        this.ticks = [];
        this.circleTransform = `rotate(-90,0,0)`;
        for (let j = 0; j < points.length; j++) {
            const { x, y } = points[j];
            let progress = j / numPoints;
            if (progress === 1) {
                progress = 0;
            }
            this.ticks.push({
                height: this.ticHeight,
                width: this.radius / 60,
                fill: this.colors.getColor(progress * this.max),
                transform: `translate(${x}, ${y}), rotate(${360 * progress - 90})`
            });
        }
    }
    getValueDomain() {
        return [0, this.max];
    }
    getDisplayValue() {
        if (this.valueFormatting) {
            return this.valueFormatting(this.value);
        }
        return this.percent + '%';
    }
    getPercentage() {
        return Math.round((this.value / this.max) * 100);
    }
    onClick() {
        this.select.emit({
            name: 'Value',
            value: this.value
        });
    }
    setColors() {
        this.colors = new ColorHelper(this.scheme, ScaleType.Linear, this.valueDomain, this.customColors);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: PercentGaugeComponent, deps: null, target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: PercentGaugeComponent, selector: "ngx-charts-percent-gauge", inputs: { max: "max", value: "value", target: "target", targetLabel: "targetLabel", label: "label", valueFormatting: "valueFormatting", showLabel: "showLabel" }, usesInheritance: true, ngImport: i0, template: `
    <ngx-charts-chart [view]="[width, height]" [showLegend]="false" [animations]="animations">
      <svg:g class="percent-gauge chart" (click)="onClick()">
        <svg:g [attr.transform]="transform">
          <mask [attr.id]="circleMaskId">
            <circle
              [attr.r]="radius"
              [style.stroke-width]="radius / 5"
              cx="0"
              cy="0"
              stroke="white"
              fill="transparent"
              [attr.stroke-dasharray]="circumference"
              transform="rotate(-90,0,0)"
              [style.stroke-dashoffset]="circumference * (1 - percent / 100)"
            />
          </mask>
          <text x="0" y="0" stroke="none" class="total" [style.font-size]="valueFontSize">
            {{ displayValue }}
          </text>
          <circle
            class="dashes-back"
            [style.stroke-width]="radius / 5"
            [attr.r]="radius"
            cx="0"
            cy="0"
            fill="none"
            [style.stroke-dasharray]="dashes"
          />

          <svg:g [attr.mask]="'url(#' + circleMaskId + ')'">
            <svg:g [attr.transform]="circleTransform">
              <svg:g *ngFor="let tic of ticks" [attr.transform]="tic.transform">
                <rect
                  [attr.y]="-tic.height / 2"
                  [attr.x]="-tic.width"
                  [attr.width]="tic.width"
                  [attr.height]="tic.height"
                  [attr.fill]="tic.fill"
                />
              </svg:g>
            </svg:g>
          </svg:g>

          <svg:g [attr.transform]="targetTransform">
            <circle
              class="target-circle-bg"
              [attr.r]="targetRadius"
              [style.stroke-width]="targetRadius / 10"
              [attr.cx]="-targetRadius / 2"
              [attr.cy]="-targetRadius / 2"
            />
            <circle
              *ngIf="percent >= target"
              class="target-circle"
              [attr.r]="targetRadius"
              [style.stroke-width]="targetRadius / 10"
              [attr.stroke]="targetColor"
              [attr.cx]="-targetRadius / 2"
              [attr.cy]="-targetRadius / 2"
            />
            <svg:g [attr.transform]="targetTextTransform">
              <text
                transform="translate(0, -4)"
                class="target-label"
                stroke="none"
                text-anchor="middle"
                [style.font-size]="12"
              >
                {{ targetLabel }}
              </text>
              <text
                transform="translate(0, 11)"
                class="target-value"
                stroke="none"
                text-anchor="middle"
                [style.font-size]="14"
              >
                {{ target }}%
              </text>
            </svg:g>
          </svg:g>
        </svg:g>
        <svg:g *ngIf="showLabel" [attr.transform]="labelTransform">
          <text class="gauge-label" x="50%" dominant-baseline="middle" text-anchor="middle" stroke="none">
            {{ label }}
          </text>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `, isInline: true, styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n", ".percent-gauge{cursor:pointer}.percent-gauge text{text-anchor:middle}.percent-gauge .dashes-back{stroke:#e7e7e7}.percent-gauge .target-circle,.percent-gauge .target-circle-bg{fill:#fff}.percent-gauge .target-circle-bg{stroke:#e7e7e7}.percent-gauge .total{dominant-baseline:middle}.percent-gauge .label{display:block;text-anchor:middle}\n"], dependencies: [{ kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i2.ChartComponent, selector: "ngx-charts-chart", inputs: ["view", "showLegend", "legendOptions", "legendType", "activeEntries", "animations"], outputs: ["legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: PercentGaugeComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ngx-charts-percent-gauge', template: `
    <ngx-charts-chart [view]="[width, height]" [showLegend]="false" [animations]="animations">
      <svg:g class="percent-gauge chart" (click)="onClick()">
        <svg:g [attr.transform]="transform">
          <mask [attr.id]="circleMaskId">
            <circle
              [attr.r]="radius"
              [style.stroke-width]="radius / 5"
              cx="0"
              cy="0"
              stroke="white"
              fill="transparent"
              [attr.stroke-dasharray]="circumference"
              transform="rotate(-90,0,0)"
              [style.stroke-dashoffset]="circumference * (1 - percent / 100)"
            />
          </mask>
          <text x="0" y="0" stroke="none" class="total" [style.font-size]="valueFontSize">
            {{ displayValue }}
          </text>
          <circle
            class="dashes-back"
            [style.stroke-width]="radius / 5"
            [attr.r]="radius"
            cx="0"
            cy="0"
            fill="none"
            [style.stroke-dasharray]="dashes"
          />

          <svg:g [attr.mask]="'url(#' + circleMaskId + ')'">
            <svg:g [attr.transform]="circleTransform">
              <svg:g *ngFor="let tic of ticks" [attr.transform]="tic.transform">
                <rect
                  [attr.y]="-tic.height / 2"
                  [attr.x]="-tic.width"
                  [attr.width]="tic.width"
                  [attr.height]="tic.height"
                  [attr.fill]="tic.fill"
                />
              </svg:g>
            </svg:g>
          </svg:g>

          <svg:g [attr.transform]="targetTransform">
            <circle
              class="target-circle-bg"
              [attr.r]="targetRadius"
              [style.stroke-width]="targetRadius / 10"
              [attr.cx]="-targetRadius / 2"
              [attr.cy]="-targetRadius / 2"
            />
            <circle
              *ngIf="percent >= target"
              class="target-circle"
              [attr.r]="targetRadius"
              [style.stroke-width]="targetRadius / 10"
              [attr.stroke]="targetColor"
              [attr.cx]="-targetRadius / 2"
              [attr.cy]="-targetRadius / 2"
            />
            <svg:g [attr.transform]="targetTextTransform">
              <text
                transform="translate(0, -4)"
                class="target-label"
                stroke="none"
                text-anchor="middle"
                [style.font-size]="12"
              >
                {{ targetLabel }}
              </text>
              <text
                transform="translate(0, 11)"
                class="target-value"
                stroke="none"
                text-anchor="middle"
                [style.font-size]="14"
              >
                {{ target }}%
              </text>
            </svg:g>
          </svg:g>
        </svg:g>
        <svg:g *ngIf="showLabel" [attr.transform]="labelTransform">
          <text class="gauge-label" x="50%" dominant-baseline="middle" text-anchor="middle" stroke="none">
            {{ label }}
          </text>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `, encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n", ".percent-gauge{cursor:pointer}.percent-gauge text{text-anchor:middle}.percent-gauge .dashes-back{stroke:#e7e7e7}.percent-gauge .target-circle,.percent-gauge .target-circle-bg{fill:#fff}.percent-gauge .target-circle-bg{stroke:#e7e7e7}.percent-gauge .total{dominant-baseline:middle}.percent-gauge .label{display:block;text-anchor:middle}\n"] }]
        }], propDecorators: { max: [{
                type: Input
            }], value: [{
                type: Input
            }], target: [{
                type: Input
            }], targetLabel: [{
                type: Input
            }], label: [{
                type: Input
            }], valueFormatting: [{
                type: Input
            }], showLabel: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVyY2VudC1nYXVnZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9zd2ltbGFuZS9uZ3gtY2hhcnRzL3NyYy9saWIvZ2F1Z2UvcGVyY2VudC1nYXVnZS9wZXJjZW50LWdhdWdlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxpQkFBaUIsRUFBRSx1QkFBdUIsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUU3RixPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQUN2RSxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUM5RSxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFFeEQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLG9DQUFvQyxDQUFDO0FBQy9ELE9BQU8sRUFBRSxFQUFFLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7OztBQW1HcEMsTUFBTSxPQUFPLHFCQUFzQixTQUFRLGtCQUFrQjtJQWpHN0Q7O1FBa0dXLFFBQUcsR0FBVyxHQUFHLENBQUM7UUFDbEIsVUFBSyxHQUFXLENBQUMsQ0FBQztRQUNsQixXQUFNLEdBQVcsRUFBRSxDQUFDO1FBQ3BCLGdCQUFXLEdBQVcsUUFBUSxDQUFDO1FBRy9CLGNBQVMsR0FBRyxJQUFJLENBQUM7UUFFMUIsa0JBQWEsR0FBYSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQzNDLFdBQU0sR0FBYSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBY3BDLFVBQUssR0FBVSxFQUFFLENBQUM7S0FzSG5CO0lBekdDLE1BQU07UUFDSixLQUFLLENBQUMsTUFBTSxFQUFFLENBQUM7UUFFZixJQUFJLENBQUMsWUFBWSxHQUFHLGFBQWEsRUFBRSxFQUFFLEVBQUUsQ0FBQztRQUV4QyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDdEMsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDbkIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDdEIsQ0FBQztRQUVELElBQUksQ0FBQyxJQUFJLEdBQUcsdUJBQXVCLENBQUM7WUFDbEMsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLO1lBQ2pCLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTTtZQUNuQixPQUFPLEVBQUUsSUFBSSxDQUFDLE1BQU07U0FDckIsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDcEMsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ2xFLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQztRQUNuRixJQUFJLENBQUMsYUFBYSxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDL0MsSUFBSSxDQUFDLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsRUFBRSxJQUFJLElBQUksQ0FBQyxhQUFhLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsRUFBRSxFQUFFLENBQUM7UUFDbEYsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDakQsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztRQUNwQyxJQUFJLENBQUMsbUJBQW1CLEdBQUcsYUFBYSxDQUFDLElBQUksQ0FBQyxZQUFZLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFlBQVksR0FBRyxDQUFDLFlBQ3ZGLElBQUksQ0FBQyxZQUFZLEdBQUcsRUFDdEIsR0FBRyxDQUFDO1FBRUosSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDekMsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7UUFFM0MsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ2pCLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUV4RSxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztRQUNyRCxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztRQUV0RCxJQUFJLENBQUMsU0FBUyxHQUFHLGFBQWEsT0FBTyxLQUFLLE9BQU8sR0FBRyxDQUFDO1FBQ3JELElBQUksQ0FBQyxjQUFjLEdBQUcsZ0JBQWdCLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztRQUVqSCxNQUFNLEtBQUssR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDOUQsSUFBSSxDQUFDLGVBQWUsR0FBRyxhQUFhLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLFlBQVksR0FBRyxDQUFDLEtBQzlGLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLFlBQVksR0FBRyxDQUM3RCxHQUFHLENBQUM7UUFFSixJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7UUFFckIsSUFBSSxDQUFDLEVBQUUsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUN6QixDQUFDO0lBRUQsb0JBQW9CLENBQUMsTUFBYyxFQUFFLFNBQWlCO1FBQ3BELE1BQU0sTUFBTSxHQUFHLEVBQUUsQ0FBQztRQUNsQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDbkMsTUFBTSxLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUM7WUFDNUMsTUFBTSxDQUFDLEdBQUcsTUFBTSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDbkMsTUFBTSxDQUFDLEdBQUcsTUFBTSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDbkMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3hCLENBQUM7UUFDRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRUQsYUFBYTtRQUNYLE1BQU0sU0FBUyxHQUFHLEVBQUUsQ0FBQztRQUNyQixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxTQUFTLENBQUMsQ0FBQztRQUNqRSxJQUFJLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQztRQUNoQixJQUFJLENBQUMsZUFBZSxHQUFHLGlCQUFpQixDQUFDO1FBQ3pDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDdkMsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDM0IsSUFBSSxRQUFRLEdBQUcsQ0FBQyxHQUFHLFNBQVMsQ0FBQztZQUM3QixJQUFJLFFBQVEsS0FBSyxDQUFDLEVBQUUsQ0FBQztnQkFDbkIsUUFBUSxHQUFHLENBQUMsQ0FBQztZQUNmLENBQUM7WUFDRCxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQztnQkFDZCxNQUFNLEVBQUUsSUFBSSxDQUFDLFNBQVM7Z0JBQ3RCLEtBQUssRUFBRSxJQUFJLENBQUMsTUFBTSxHQUFHLEVBQUU7Z0JBQ3ZCLElBQUksRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztnQkFDL0MsU0FBUyxFQUFFLGFBQWEsQ0FBQyxLQUFLLENBQUMsYUFBYSxHQUFHLEdBQUcsUUFBUSxHQUFHLEVBQUUsR0FBRzthQUNuRSxDQUFDLENBQUM7UUFDTCxDQUFDO0lBQ0gsQ0FBQztJQUVELGNBQWM7UUFDWixPQUFPLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQsZUFBZTtRQUNiLElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1lBQ3pCLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDMUMsQ0FBQztRQUNELE9BQU8sSUFBSSxDQUFDLE9BQU8sR0FBRyxHQUFHLENBQUM7SUFDNUIsQ0FBQztJQUVELGFBQWE7UUFDWCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBRUQsT0FBTztRQUNMLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDO1lBQ2YsSUFBSSxFQUFFLE9BQU87WUFDYixLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUs7U0FDbEIsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELFNBQVM7UUFDUCxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUNwRyxDQUFDOytHQTdJVSxxQkFBcUI7bUdBQXJCLHFCQUFxQix5UEEvRnRCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0EwRlQ7OzRGQUtVLHFCQUFxQjtrQkFqR2pDLFNBQVM7K0JBQ0UsMEJBQTBCLFlBQzFCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0EwRlQsaUJBRWMsaUJBQWlCLENBQUMsSUFBSSxtQkFDcEIsdUJBQXVCLENBQUMsTUFBTTs4QkFHdEMsR0FBRztzQkFBWCxLQUFLO2dCQUNHLEtBQUs7c0JBQWIsS0FBSztnQkFDRyxNQUFNO3NCQUFkLEtBQUs7Z0JBQ0csV0FBVztzQkFBbkIsS0FBSztnQkFDRyxLQUFLO3NCQUFiLEtBQUs7Z0JBQ0csZUFBZTtzQkFBdkIsS0FBSztnQkFDRyxTQUFTO3NCQUFqQixLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgVmlld0VuY2Fwc3VsYXRpb24sIENoYW5nZURldGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEJhc2VDaGFydENvbXBvbmVudCB9IGZyb20gJy4uLy4uL2NvbW1vbi9iYXNlLWNoYXJ0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyB9IGZyb20gJy4uLy4uL2NvbW1vbi92aWV3LWRpbWVuc2lvbnMuaGVscGVyJztcbmltcG9ydCB7IENvbG9ySGVscGVyIH0gZnJvbSAnLi4vLi4vY29tbW9uL2NvbG9yLmhlbHBlcic7XG5pbXBvcnQgeyBWaWV3RGltZW5zaW9ucyB9IGZyb20gJy4uLy4uL2NvbW1vbi90eXBlcy92aWV3LWRpbWVuc2lvbi5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU2NhbGVUeXBlIH0gZnJvbSAnLi4vLi4vY29tbW9uL3R5cGVzL3NjYWxlLXR5cGUuZW51bSc7XG5pbXBvcnQgeyBpZCB9IGZyb20gJy4uLy4uL3V0aWxzL2lkJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1wZXJjZW50LWdhdWdlJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmd4LWNoYXJ0cy1jaGFydCBbdmlld109XCJbd2lkdGgsIGhlaWdodF1cIiBbc2hvd0xlZ2VuZF09XCJmYWxzZVwiIFthbmltYXRpb25zXT1cImFuaW1hdGlvbnNcIj5cbiAgICAgIDxzdmc6ZyBjbGFzcz1cInBlcmNlbnQtZ2F1Z2UgY2hhcnRcIiAoY2xpY2spPVwib25DbGljaygpXCI+XG4gICAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVwidHJhbnNmb3JtXCI+XG4gICAgICAgICAgPG1hc2sgW2F0dHIuaWRdPVwiY2lyY2xlTWFza0lkXCI+XG4gICAgICAgICAgICA8Y2lyY2xlXG4gICAgICAgICAgICAgIFthdHRyLnJdPVwicmFkaXVzXCJcbiAgICAgICAgICAgICAgW3N0eWxlLnN0cm9rZS13aWR0aF09XCJyYWRpdXMgLyA1XCJcbiAgICAgICAgICAgICAgY3g9XCIwXCJcbiAgICAgICAgICAgICAgY3k9XCIwXCJcbiAgICAgICAgICAgICAgc3Ryb2tlPVwid2hpdGVcIlxuICAgICAgICAgICAgICBmaWxsPVwidHJhbnNwYXJlbnRcIlxuICAgICAgICAgICAgICBbYXR0ci5zdHJva2UtZGFzaGFycmF5XT1cImNpcmN1bWZlcmVuY2VcIlxuICAgICAgICAgICAgICB0cmFuc2Zvcm09XCJyb3RhdGUoLTkwLDAsMClcIlxuICAgICAgICAgICAgICBbc3R5bGUuc3Ryb2tlLWRhc2hvZmZzZXRdPVwiY2lyY3VtZmVyZW5jZSAqICgxIC0gcGVyY2VudCAvIDEwMClcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L21hc2s+XG4gICAgICAgICAgPHRleHQgeD1cIjBcIiB5PVwiMFwiIHN0cm9rZT1cIm5vbmVcIiBjbGFzcz1cInRvdGFsXCIgW3N0eWxlLmZvbnQtc2l6ZV09XCJ2YWx1ZUZvbnRTaXplXCI+XG4gICAgICAgICAgICB7eyBkaXNwbGF5VmFsdWUgfX1cbiAgICAgICAgICA8L3RleHQ+XG4gICAgICAgICAgPGNpcmNsZVxuICAgICAgICAgICAgY2xhc3M9XCJkYXNoZXMtYmFja1wiXG4gICAgICAgICAgICBbc3R5bGUuc3Ryb2tlLXdpZHRoXT1cInJhZGl1cyAvIDVcIlxuICAgICAgICAgICAgW2F0dHIucl09XCJyYWRpdXNcIlxuICAgICAgICAgICAgY3g9XCIwXCJcbiAgICAgICAgICAgIGN5PVwiMFwiXG4gICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICBbc3R5bGUuc3Ryb2tlLWRhc2hhcnJheV09XCJkYXNoZXNcIlxuICAgICAgICAgIC8+XG5cbiAgICAgICAgICA8c3ZnOmcgW2F0dHIubWFza109XCIndXJsKCMnICsgY2lyY2xlTWFza0lkICsgJyknXCI+XG4gICAgICAgICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cImNpcmNsZVRyYW5zZm9ybVwiPlxuICAgICAgICAgICAgICA8c3ZnOmcgKm5nRm9yPVwibGV0IHRpYyBvZiB0aWNrc1wiIFthdHRyLnRyYW5zZm9ybV09XCJ0aWMudHJhbnNmb3JtXCI+XG4gICAgICAgICAgICAgICAgPHJlY3RcbiAgICAgICAgICAgICAgICAgIFthdHRyLnldPVwiLXRpYy5oZWlnaHQgLyAyXCJcbiAgICAgICAgICAgICAgICAgIFthdHRyLnhdPVwiLXRpYy53aWR0aFwiXG4gICAgICAgICAgICAgICAgICBbYXR0ci53aWR0aF09XCJ0aWMud2lkdGhcIlxuICAgICAgICAgICAgICAgICAgW2F0dHIuaGVpZ2h0XT1cInRpYy5oZWlnaHRcIlxuICAgICAgICAgICAgICAgICAgW2F0dHIuZmlsbF09XCJ0aWMuZmlsbFwiXG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPC9zdmc6Zz5cbiAgICAgICAgICAgIDwvc3ZnOmc+XG4gICAgICAgICAgPC9zdmc6Zz5cblxuICAgICAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVwidGFyZ2V0VHJhbnNmb3JtXCI+XG4gICAgICAgICAgICA8Y2lyY2xlXG4gICAgICAgICAgICAgIGNsYXNzPVwidGFyZ2V0LWNpcmNsZS1iZ1wiXG4gICAgICAgICAgICAgIFthdHRyLnJdPVwidGFyZ2V0UmFkaXVzXCJcbiAgICAgICAgICAgICAgW3N0eWxlLnN0cm9rZS13aWR0aF09XCJ0YXJnZXRSYWRpdXMgLyAxMFwiXG4gICAgICAgICAgICAgIFthdHRyLmN4XT1cIi10YXJnZXRSYWRpdXMgLyAyXCJcbiAgICAgICAgICAgICAgW2F0dHIuY3ldPVwiLXRhcmdldFJhZGl1cyAvIDJcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxjaXJjbGVcbiAgICAgICAgICAgICAgKm5nSWY9XCJwZXJjZW50ID49IHRhcmdldFwiXG4gICAgICAgICAgICAgIGNsYXNzPVwidGFyZ2V0LWNpcmNsZVwiXG4gICAgICAgICAgICAgIFthdHRyLnJdPVwidGFyZ2V0UmFkaXVzXCJcbiAgICAgICAgICAgICAgW3N0eWxlLnN0cm9rZS13aWR0aF09XCJ0YXJnZXRSYWRpdXMgLyAxMFwiXG4gICAgICAgICAgICAgIFthdHRyLnN0cm9rZV09XCJ0YXJnZXRDb2xvclwiXG4gICAgICAgICAgICAgIFthdHRyLmN4XT1cIi10YXJnZXRSYWRpdXMgLyAyXCJcbiAgICAgICAgICAgICAgW2F0dHIuY3ldPVwiLXRhcmdldFJhZGl1cyAvIDJcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVwidGFyZ2V0VGV4dFRyYW5zZm9ybVwiPlxuICAgICAgICAgICAgICA8dGV4dFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgwLCAtNClcIlxuICAgICAgICAgICAgICAgIGNsYXNzPVwidGFyZ2V0LWxhYmVsXCJcbiAgICAgICAgICAgICAgICBzdHJva2U9XCJub25lXCJcbiAgICAgICAgICAgICAgICB0ZXh0LWFuY2hvcj1cIm1pZGRsZVwiXG4gICAgICAgICAgICAgICAgW3N0eWxlLmZvbnQtc2l6ZV09XCIxMlwiXG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7eyB0YXJnZXRMYWJlbCB9fVxuICAgICAgICAgICAgICA8L3RleHQ+XG4gICAgICAgICAgICAgIDx0ZXh0XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDAsIDExKVwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJ0YXJnZXQtdmFsdWVcIlxuICAgICAgICAgICAgICAgIHN0cm9rZT1cIm5vbmVcIlxuICAgICAgICAgICAgICAgIHRleHQtYW5jaG9yPVwibWlkZGxlXCJcbiAgICAgICAgICAgICAgICBbc3R5bGUuZm9udC1zaXplXT1cIjE0XCJcbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHt7IHRhcmdldCB9fSVcbiAgICAgICAgICAgICAgPC90ZXh0PlxuICAgICAgICAgICAgPC9zdmc6Zz5cbiAgICAgICAgICA8L3N2ZzpnPlxuICAgICAgICA8L3N2ZzpnPlxuICAgICAgICA8c3ZnOmcgKm5nSWY9XCJzaG93TGFiZWxcIiBbYXR0ci50cmFuc2Zvcm1dPVwibGFiZWxUcmFuc2Zvcm1cIj5cbiAgICAgICAgICA8dGV4dCBjbGFzcz1cImdhdWdlLWxhYmVsXCIgeD1cIjUwJVwiIGRvbWluYW50LWJhc2VsaW5lPVwibWlkZGxlXCIgdGV4dC1hbmNob3I9XCJtaWRkbGVcIiBzdHJva2U9XCJub25lXCI+XG4gICAgICAgICAgICB7eyBsYWJlbCB9fVxuICAgICAgICAgIDwvdGV4dD5cbiAgICAgICAgPC9zdmc6Zz5cbiAgICAgIDwvc3ZnOmc+XG4gICAgPC9uZ3gtY2hhcnRzLWNoYXJ0PlxuICBgLFxuICBzdHlsZVVybHM6IFsnLi4vLi4vY29tbW9uL2Jhc2UtY2hhcnQuY29tcG9uZW50LnNjc3MnLCAnLi9wZXJjZW50LWdhdWdlLmNvbXBvbmVudC5zY3NzJ10sXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIFBlcmNlbnRHYXVnZUNvbXBvbmVudCBleHRlbmRzIEJhc2VDaGFydENvbXBvbmVudCB7XG4gIEBJbnB1dCgpIG1heDogbnVtYmVyID0gMTAwO1xuICBASW5wdXQoKSB2YWx1ZTogbnVtYmVyID0gMDtcbiAgQElucHV0KCkgdGFyZ2V0OiBudW1iZXIgPSA3NTtcbiAgQElucHV0KCkgdGFyZ2V0TGFiZWw6IHN0cmluZyA9ICdUYXJnZXQnO1xuICBASW5wdXQoKSBsYWJlbDogc3RyaW5nO1xuICBASW5wdXQoKSB2YWx1ZUZvcm1hdHRpbmc6IGFueTtcbiAgQElucHV0KCkgc2hvd0xhYmVsID0gdHJ1ZTtcblxuICBkZWZhdWx0TWFyZ2luOiBudW1iZXJbXSA9IFsyMCwgNDAsIDIwLCA0MF07XG4gIG1hcmdpbjogbnVtYmVyW10gPSBbMjAsIDQwLCAyMCwgNDBdO1xuICBkaW1zOiBWaWV3RGltZW5zaW9ucztcblxuICBjb2xvcnM6IENvbG9ySGVscGVyO1xuICByYWRpdXM6IG51bWJlcjtcbiAgdHJhbnNmb3JtOiBzdHJpbmc7XG5cbiAgdGFyZ2V0VHJhbnNmb3JtOiBzdHJpbmc7XG4gIHRhcmdldENvbG9yOiBzdHJpbmc7XG4gIHRhcmdldFJhZGl1czogbnVtYmVyO1xuICB0YXJnZXRUZXh0VHJhbnNmb3JtOiBzdHJpbmc7XG5cbiAgY2lyY2xlTWFza0lkOiBzdHJpbmc7XG4gIGNpcmNsZVRyYW5zZm9ybTogc3RyaW5nO1xuICB0aWNrczogYW55W10gPSBbXTtcbiAgdGljSGVpZ2h0OiBudW1iZXI7XG5cbiAgZGFzaGVzOiBzdHJpbmc7XG5cbiAgdmFsdWVEb21haW46IFtudW1iZXIsIG51bWJlcl07XG4gIHZhbHVlRm9udFNpemU6IG51bWJlcjtcbiAgZGlzcGxheVZhbHVlOiBzdHJpbmc7XG4gIHBlcmNlbnQ6IG51bWJlcjtcbiAgY2lyY3VtZmVyZW5jZTogbnVtYmVyO1xuXG4gIGxhYmVsVHJhbnNmb3JtOiBzdHJpbmc7XG5cbiAgdXBkYXRlKCk6IHZvaWQge1xuICAgIHN1cGVyLnVwZGF0ZSgpO1xuXG4gICAgdGhpcy5jaXJjbGVNYXNrSWQgPSBgY2lyY2xlTWFzayR7aWQoKX1gO1xuXG4gICAgdGhpcy5tYXJnaW4gPSBbLi4udGhpcy5kZWZhdWx0TWFyZ2luXTtcbiAgICBpZiAodGhpcy5zaG93TGFiZWwpIHtcbiAgICAgIHRoaXMubWFyZ2luWzJdID0gNTA7XG4gICAgfVxuXG4gICAgdGhpcy5kaW1zID0gY2FsY3VsYXRlVmlld0RpbWVuc2lvbnMoe1xuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgbWFyZ2luczogdGhpcy5tYXJnaW5cbiAgICB9KTtcblxuICAgIHRoaXMucGVyY2VudCA9IHRoaXMuZ2V0UGVyY2VudGFnZSgpO1xuICAgIHRoaXMudGljSGVpZ2h0ID0gTWF0aC5taW4odGhpcy5kaW1zLndpZHRoLCB0aGlzLmRpbXMuaGVpZ2h0KSAvIDEwO1xuICAgIHRoaXMucmFkaXVzID0gTWF0aC5taW4odGhpcy5kaW1zLndpZHRoLCB0aGlzLmRpbXMuaGVpZ2h0KSAvIDIgLSB0aGlzLnRpY0hlaWdodCAvIDI7XG4gICAgdGhpcy5jaXJjdW1mZXJlbmNlID0gMiAqIE1hdGguUEkgKiB0aGlzLnJhZGl1cztcbiAgICB0aGlzLmRhc2hlcyA9IGAke3RoaXMucmFkaXVzIC8gNjB9ICR7dGhpcy5jaXJjdW1mZXJlbmNlIC8gNjAgLSB0aGlzLnJhZGl1cyAvIDYwfWA7XG4gICAgdGhpcy52YWx1ZUZvbnRTaXplID0gTWF0aC5mbG9vcih0aGlzLnJhZGl1cyAvIDMpO1xuICAgIHRoaXMudGFyZ2V0UmFkaXVzID0gdGhpcy5yYWRpdXMgLyA0O1xuICAgIHRoaXMudGFyZ2V0VGV4dFRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHstdGhpcy50YXJnZXRSYWRpdXMgLyAyfSwgJHstdGhpcy50YXJnZXRSYWRpdXMgLyAyfSksIHNjYWxlKCR7XG4gICAgICB0aGlzLnRhcmdldFJhZGl1cyAvIDI4XG4gICAgfSlgO1xuXG4gICAgdGhpcy52YWx1ZURvbWFpbiA9IHRoaXMuZ2V0VmFsdWVEb21haW4oKTtcbiAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9IHRoaXMuZ2V0RGlzcGxheVZhbHVlKCk7XG5cbiAgICB0aGlzLnNldENvbG9ycygpO1xuICAgIHRoaXMudGFyZ2V0Q29sb3IgPSB0aGlzLmNvbG9ycy5nZXRDb2xvcigodGhpcy50YXJnZXQgLyAxMDApICogdGhpcy5tYXgpO1xuXG4gICAgY29uc3QgeE9mZnNldCA9IHRoaXMubWFyZ2luWzNdICsgdGhpcy5kaW1zLndpZHRoIC8gMjtcbiAgICBjb25zdCB5T2Zmc2V0ID0gdGhpcy5tYXJnaW5bMF0gKyB0aGlzLmRpbXMuaGVpZ2h0IC8gMjtcblxuICAgIHRoaXMudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke3hPZmZzZXR9LCAke3lPZmZzZXR9KWA7XG4gICAgdGhpcy5sYWJlbFRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoMCwgJHt0aGlzLmhlaWdodCAvIDIgKyB0aGlzLnJhZGl1cyArIHRoaXMubWFyZ2luWzBdICsgdGhpcy50aWNIZWlnaHQgLyAyIC0gM30pYDtcblxuICAgIGNvbnN0IGFuZ2xlID0gKHRoaXMudGFyZ2V0IC8gMTAwKSAqIE1hdGguUEkgKiAyIC0gTWF0aC5QSSAvIDI7XG4gICAgdGhpcy50YXJnZXRUcmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7dGhpcy5yYWRpdXMgKiAwLjk3ICogTWF0aC5jb3MoYW5nbGUpICsgdGhpcy50YXJnZXRSYWRpdXMgLyAyfSwgJHtcbiAgICAgIHRoaXMucmFkaXVzICogMC45NyAqIE1hdGguc2luKGFuZ2xlKSArIHRoaXMudGFyZ2V0UmFkaXVzIC8gMlxuICAgIH0pYDtcblxuICAgIHRoaXMuZ2VuZXJhdGV0aWNrcygpO1xuXG4gICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuXG4gIGdlbmVyYXRlQ2lyY2xlUG9pbnRzKHJhZGl1czogbnVtYmVyLCBudW1Qb2ludHM6IG51bWJlcik6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfVtdIHtcbiAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBvaW50czsgaSsrKSB7XG4gICAgICBjb25zdCBhbmdsZSA9IChpIC8gbnVtUG9pbnRzKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgY29uc3QgeCA9IHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgIGNvbnN0IHkgPSByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICBwb2ludHMucHVzaCh7IHgsIHkgfSk7XG4gICAgfVxuICAgIHJldHVybiBwb2ludHM7XG4gIH1cblxuICBnZW5lcmF0ZXRpY2tzKCkge1xuICAgIGNvbnN0IG51bVBvaW50cyA9IDYwO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuZ2VuZXJhdGVDaXJjbGVQb2ludHModGhpcy5yYWRpdXMsIG51bVBvaW50cyk7XG4gICAgdGhpcy50aWNrcyA9IFtdO1xuICAgIHRoaXMuY2lyY2xlVHJhbnNmb3JtID0gYHJvdGF0ZSgtOTAsMCwwKWA7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBwb2ludHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcG9pbnRzW2pdO1xuICAgICAgbGV0IHByb2dyZXNzID0gaiAvIG51bVBvaW50cztcbiAgICAgIGlmIChwcm9ncmVzcyA9PT0gMSkge1xuICAgICAgICBwcm9ncmVzcyA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLnRpY2tzLnB1c2goe1xuICAgICAgICBoZWlnaHQ6IHRoaXMudGljSGVpZ2h0LFxuICAgICAgICB3aWR0aDogdGhpcy5yYWRpdXMgLyA2MCxcbiAgICAgICAgZmlsbDogdGhpcy5jb2xvcnMuZ2V0Q29sb3IocHJvZ3Jlc3MgKiB0aGlzLm1heCksXG4gICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgke3h9LCAke3l9KSwgcm90YXRlKCR7MzYwICogcHJvZ3Jlc3MgLSA5MH0pYFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0VmFsdWVEb21haW4oKTogW251bWJlciwgbnVtYmVyXSB7XG4gICAgcmV0dXJuIFswLCB0aGlzLm1heF07XG4gIH1cblxuICBnZXREaXNwbGF5VmFsdWUoKTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy52YWx1ZUZvcm1hdHRpbmcpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlRm9ybWF0dGluZyh0aGlzLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGVyY2VudCArICclJztcbiAgfVxuXG4gIGdldFBlcmNlbnRhZ2UoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCgodGhpcy52YWx1ZSAvIHRoaXMubWF4KSAqIDEwMCk7XG4gIH1cblxuICBvbkNsaWNrKCk6IHZvaWQge1xuICAgIHRoaXMuc2VsZWN0LmVtaXQoe1xuICAgICAgbmFtZTogJ1ZhbHVlJyxcbiAgICAgIHZhbHVlOiB0aGlzLnZhbHVlXG4gICAgfSk7XG4gIH1cblxuICBzZXRDb2xvcnMoKTogdm9pZCB7XG4gICAgdGhpcy5jb2xvcnMgPSBuZXcgQ29sb3JIZWxwZXIodGhpcy5zY2hlbWUsIFNjYWxlVHlwZS5MaW5lYXIsIHRoaXMudmFsdWVEb21haW4sIHRoaXMuY3VzdG9tQ29sb3JzKTtcbiAgfVxufVxuIl19